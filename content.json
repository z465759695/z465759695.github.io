{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-01-04T08:31:38.000Z","updated":"2018-01-04T08:31:38.065Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-04T08:31:53.000Z","updated":"2018-01-04T08:31:53.075Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"hiredis文档","slug":"hiredis","date":"2018-01-04T08:29:03.000Z","updated":"2018-01-04T08:40:32.012Z","comments":true,"path":"2018/01/04/hiredis/","link":"","permalink":"http://yoursite.com/2018/01/04/hiredis/","excerpt":"","text":"Version 0.9.0 is a major overhaul of hiredis in every aspect. However, upgrading existingcode using hiredis should not be a big pain. The key thing to keep in mind whenupgrading is that hiredis &gt;= 0.9.0 uses a redisContext* to keep state, in contrast tothe stateless 0.0.1 that only has a file descriptor to work with. Synchronous APITo consume the synchronous API, there are only a few function calls that need to be introduced: 123redisContext *redisConnect(const char *ip, int port);void *redisCommand(redisContext *c, const char *format, ...);void freeReplyObject(void *reply); ConnectingThe function redisConnect is used to create a so-called redisContext. Thecontext is where Hiredis holds state for a connection. The redisContextstruct has an integer err field that is non-zero when the connection is inan error state. The field errstr will contain a string with a description ofthe error. More information on errors can be found in the Errors section.After trying to connect to Redis using redisConnect you shouldcheck the err field to see if establishing the connection was successful:12345redisContext *c = redisConnect(\"127.0.0.1\", 6379);if (c != NULL &amp;&amp; c-&gt;err) &#123; printf(\"Error: %s\\n\", c-&gt;errstr); // handle error&#125; Sending commandsThere are several ways to issue commands to Redis. The first that will be introduced isredisCommand. This function takes a format similar to printf. In the simplest form,it is used like this:1reply = redisCommand(context, \"SET foo bar\"); The specifier %s interpolates a string in the command, and uses strlen todetermine the length of the string:1reply = redisCommand(context, \"SET foo %s\", value); When you need to pass binary safe strings in a command, the %b specifier can beused. Together with a pointer to the string, it requires a size_t length argumentof the string:1reply = redisCommand(context, \"SET foo %b\", value, (size_t) valuelen); Internally, Hiredis splits the command in different arguments and willconvert it to the protocol used to communicate with Redis.One or more spaces separates arguments, so you can use the specifiersanywhere in an argument:1reply = redisCommand(context, \"SET key:%s %s\", myid, value); Using repliesThe return value of redisCommand holds a reply when the command wassuccessfully executed. When an error occurs, the return value is NULL andthe err field in the context will be set (see section on Errors).Once an error is returned the context cannot be reused and you should set upa new connection. The standard replies that redisCommand are of the type redisReply. Thetype field in the redisReply should be used to test what kind of replywas received: REDIS_REPLY_STATUS: The command replied with a status reply. The status string can be accessed using reply-&gt;str.The length of this string can be accessed using reply-&gt;len. REDIS_REPLY_ERROR: The command replied with an error. The error string can be accessed identical to REDIS_REPLY_STATUS. REDIS_REPLY_INTEGER: The command replied with an integer. The integer value can be accessed using thereply-&gt;integer field of type long long. REDIS_REPLY_NIL: The command replied with a nil object. There is no data to access. REDIS_REPLY_STRING: A bulk (string) reply. The value of the reply can be accessed using reply-&gt;str.The length of this string can be accessed using reply-&gt;len. REDIS_REPLY_ARRAY: A multi bulk reply. The number of elements in the multi bulk reply is stored inreply-&gt;elements. Every element in the multi bulk reply is a redisReply object as welland can be accessed via reply-&gt;element[..index..].Redis may reply with nested arrays but this is fully supported. Replies should be freed using the freeReplyObject() function.Note that this function will take care of freeing sub-reply objectscontained in arrays and nested arrays, so there is no need for the user tofree the sub replies (it is actually harmful and will corrupt the memory). Important: the current version of hiredis (0.10.0) frees replies when theasynchronous API is used. This means you should not call freeReplyObject whenyou use this API. The reply is cleaned up by hiredis after the callbackreturns. This behavior will probably change in future releases, so make sure tokeep an eye on the changelog when upgrading (see issue #39). Cleaning upTo disconnect and free the context the following function can be used:1void redisFree(redisContext *c); This function immediately closes the socket and then frees the allocations done increating the context. Sending commands (cont’d)Together with redisCommand, the function redisCommandArgv can be used to issue commands.It has the following prototype:1void *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen); It takes the number of arguments argc, an array of strings argv and the lengths of thearguments argvlen. For convenience, argvlen may be set to NULL and the function willuse strlen(3) on every argument to determine its length. Obviously, when any of the argumentsneed to be binary safe, the entire array of lengths argvlen should be provided. The return value has the same semantic as redisCommand. PipeliningTo explain how Hiredis supports pipelining in a blocking connection, there needs to beunderstanding of the internal execution flow. When any of the functions in the redisCommand family is called, Hiredis first formats thecommand according to the Redis protocol. The formatted command is then put in the output bufferof the context. This output buffer is dynamic, so it can hold any number of commands.After the command is put in the output buffer, redisGetReply is called. This function has thefollowing two execution paths: The input buffer is non-empty: Try to parse a single reply from the input buffer and return it If no reply could be parsed, continue at 2 The input buffer is empty: Write the entire output buffer to the socket Read from the socket until a single reply could be parsed The function redisGetReply is exported as part of the Hiredis API and can be used when a replyis expected on the socket. To pipeline commands, the only things that needs to be done isfilling up the output buffer. For this cause, two commands can be used that are identicalto the redisCommand family, apart from not returning a reply:12void redisAppendCommand(redisContext *c, const char *format, ...);void redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen); After calling either function one or more times, redisGetReply can be used to receive thesubsequent replies. The return value for this function is either REDIS_OK or REDIS_ERR, wherethe latter means an error occurred while reading a reply. Just as with the other commands,the err field in the context can be used to find out what the cause of this error is. The following examples shows a simple pipeline (resulting in only a single call to write(2) anda single call to read(2)):1234567redisReply *reply;redisAppendCommand(context,\"SET foo bar\");redisAppendCommand(context,\"GET foo\");redisGetReply(context,&amp;reply); // reply for SETfreeReplyObject(reply);redisGetReply(context,&amp;reply); // reply for GETfreeReplyObject(reply); This API can also be used to implement a blocking subscriber:123456reply = redisCommand(context,\"SUBSCRIBE foo\");freeReplyObject(reply);while(redisGetReply(context,&amp;reply) == REDIS_OK) &#123; // consume message freeReplyObject(reply);&#125; ErrorsWhen a function call is not successful, depending on the function either NULL or REDIS_ERR isreturned. The err field inside the context will be non-zero and set to one of thefollowing constants: REDIS_ERR_IO: There was an I/O error while creating the connection, trying to write to the socket or read from the socket. If you included errno.h in your application, you can use the global errno variable to find out what is wrong. REDIS_ERR_EOF: The server closed the connection which resulted in an empty read. REDIS_ERR_PROTOCOL: There was an error while parsing the protocol. REDIS_ERR_OTHER: Any other error. Currently, it is only used when a specified hostname to connect to cannot be resolved. In every case, the errstr field in the context will be set to hold a string representationof the error. Asynchronous APIHiredis comes with an asynchronous API that works easily with any event library.Examples are bundled that show using Hiredis with libevand libevent. ConnectingThe function redisAsyncConnect can be used to establish a non-blocking connection toRedis. It returns a pointer to the newly created redisAsyncContext struct. The err fieldshould be checked after creation to see if there were errors creating the connection.Because the connection that will be created is non-blocking, the kernel is not able toinstantly return if the specified host and port is able to accept a connection.12345redisAsyncContext *c = redisAsyncConnect(\"127.0.0.1\", 6379);if (c-&gt;err) &#123; printf(\"Error: %s\\n\", c-&gt;errstr); // handle error&#125; The asynchronous context can hold a disconnect callback function that is called when theconnection is disconnected (either because of an error or per user request). This function shouldhave the following prototype:1void(const redisAsyncContext *c, int status); On a disconnect, the status argument is set to REDIS_OK when disconnection was initiated by theuser, or REDIS_ERR when the disconnection was caused by an error. When it is REDIS_ERR, the errfield in the context can be accessed to find out the cause of the error. The context object is always freed after the disconnect callback fired. When a reconnect is needed,the disconnect callback is a good point to do so. Setting the disconnect callback can only be done once per context. For subsequent calls it willreturn REDIS_ERR. The function to set the disconnect callback has the following prototype:1int redisAsyncSetDisconnectCallback(redisAsyncContext *ac, redisDisconnectCallback *fn); Sending commands and their callbacksIn an asynchronous context, commands are automatically pipelined due to the nature of an event loop.Therefore, unlike the synchronous API, there is only a single way to send commands.Because commands are sent to Redis asynchronously, issuing a command requires a callback functionthat is called when the reply is received. Reply callbacks should have the following prototype:1void(redisAsyncContext *c, void *reply, void *privdata); The privdata argument can be used to curry arbitrary data to the callback from the point wherethe command is initially queued for execution. The functions that can be used to issue commands in an asynchronous context are:123456int redisAsyncCommand( redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, ...);int redisAsyncCommandArgv( redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, int argc, const char **argv, const size_t *argvlen); Both functions work like their blocking counterparts. The return value is REDIS_OK when the commandwas successfully added to the output buffer and REDIS_ERR otherwise. Example: when the connectionis being disconnected per user-request, no new commands may be added to the output buffer and REDIS_ERR isreturned on calls to the redisAsyncCommand family. If the reply for a command with a NULL callback is read, it is immediately freed. When the callbackfor a command is non-NULL, the memory is freed immediately following the callback: the reply is onlyvalid for the duration of the callback. All pending callbacks are called with a NULL reply when the context encountered an error. DisconnectingAn asynchronous connection can be terminated using:1void redisAsyncDisconnect(redisAsyncContext *ac); When this function is called, the connection is not immediately terminated. Instead, newcommands are no longer accepted and the connection is only terminated when all pending commandshave been written to the socket, their respective replies have been read and their respectivecallbacks have been executed. After this, the disconnection callback is executed with theREDIS_OK status and the context object is freed. Hooking it up to event library XThere are a few hooks that need to be set on the context object after it is created.See the adapters/ directory for bindings to libev and libevent. Reply parsing APIHiredis comes with a reply parsing API that makes it easy for writing higherlevel language bindings. The reply parsing API consists of the following functions:1234redisReader *redisReaderCreate(void);void redisReaderFree(redisReader *reader);int redisReaderFeed(redisReader *reader, const char *buf, size_t len);int redisReaderGetReply(redisReader *reader, void **reply); The same set of functions are used internally by hiredis when creating anormal Redis context, the above API just exposes it to the user for a directusage. UsageThe function redisReaderCreate creates a redisReader structure that holds abuffer with unparsed data and state for the protocol parser. Incoming data – most likely from a socket – can be placed in the internalbuffer of the redisReader using redisReaderFeed. This function will make acopy of the buffer pointed to by buf for len bytes. This data is parsedwhen redisReaderGetReply is called. This function returns an integer statusand a reply object (as described above) via void **reply. The returned statuscan be either REDIS_OK or REDIS_ERR, where the latter means something wentwrong (either a protocol error, or an out of memory error). The parser limits the level of nesting for multi bulk payloads to 7. If themulti bulk nesting level is higher than this, the parser returns an error. Customizing repliesThe function redisReaderGetReply creates redisReply and makes the functionargument reply point to the created redisReply variable. For instance, ifthe response of type REDIS_REPLY_STATUS then the str field of redisReplywill hold the status as a vanilla C string. However, the functions that areresponsible for creating instances of the redisReply can be customized bysetting the fn field on the redisReader struct. This should be doneimmediately after creating the redisReader. For example, hiredis-rbuses customized reply object functions to create Ruby objects. Reader max bufferBoth when using the Reader API directly or when using it indirectly via anormal Redis context, the redisReader structure uses a buffer in order toaccumulate data from the server.Usually this buffer is destroyed when it is empty and is larger than 16KiB in order to avoid wasting memory in unused buffers However when working with very big payloads destroying the buffer may slowdown performances considerably, so it is possible to modify the max size ofan idle buffer changing the value of the maxbuf field of the reader structureto the desired value. The special value of 0 means that there is no maximumvalue for an idle buffer, so the buffer will never get freed. For instance if you have a normal Redis context you can set the maximum idlebuffer to zero (unlimited) just with:1context-&gt;reader-&gt;maxbuf = 0; This should be done only in order to maximize performances when working withlarge payloads. The context should be set back to REDIS_READER_MAX_BUF againas soon as possible in order to prevent allocation of useless memory. AUTHORSHiredis was written by Salvatore Sanfilippo (antirez at gmail) andPieter Noordhuis (pcnoordhuis at gmail) and is released under the BSD license.Hiredis is currently maintained by Matt Stancliff (matt at genges dot com) andJan-Erik Rediger (janerik at fnordig dot com)","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]}]}